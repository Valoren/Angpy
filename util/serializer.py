import json
import time
import traceback
import types

import container
import mapgen.gameMap
import util.id

## The Serializer and Deserializer classes are used to [de]serialize game state
# by converting it to/from JSON. 
# To qualify for [de]serialization, an object must:
# - have the function getSerializationDict(), which returns a dict that 
#   can later be used to recreate the object. The dict doesn't need to be 
#   completely ready for serialization (it can contain object references and
#   the like); it will be cleaned as part of the serialization process.
# - have an 'id' field that is unique across all objects in the entire game, 
#   and can be manually set when deserializing (thus, cannot be the Python
#   object ID produced by the builtin function id()). Must use the util.id
#   module for this.
# - have its type registered with the registerObjectClass() function. This 
#   in turn requires the existence of two functions: one that creates a "bare"
#   instance of the object, and one that fills in its data when provided with
#   an appropriate dict. 
#
# To use the Serializer, create it, add whatever containers and other objects
# you want to it, and then call its writeFile() function. 
# 
# Note: one of the primary goals of this system is to avoid having any actual
# code in the savefile. Thus why we don't use pickle or other existing 
# automatic serialization systems -- they can have just about anything in them,
# so you have to trust your inputs to not be malicious. As a result, lambda
# functions cannot be serialized. 
# 
# On a similar note, if we ever added a database to Pyrel, we would need to
# be certain not to include database queries in the savefile...



## Fill in data in the provided object by just blindly copying it through with
# setattr. This can serve as a useful default option for objects that don't
# need complicated deserialization.
def basicDataFill(obj, data, gameMap):
    for key, value in data.iteritems():
        setattr(obj, key, value)


## Maps strings (representing object class names) to 
# (constructorFunc, fillFunc) tuples. See the registerObjectClass() function.
NAME_TO_DESERIALIZATION_FUNCS = {}


## Register an object class so that it can be deserialized. 
# \param objectType Type of the object (as generated by 
#        ObjectType.__name__ or objectInstance.__class__.__name__)
# \param constructorFunc Function used to create a bare-bones instance of 
#        the object.
# \param fillFunc Function used to fill in the details of the object. Defaults
#        to basicDataFill(). 
def registerObjectClass(name, constructorFunc, fillFunc = basicDataFill):
    NAME_TO_DESERIALIZATION_FUNCS[name] = (constructorFunc, fillFunc)



## This class handles creating savefiles. Usage:
# serializer = Serializer()
# serializer.addContainer(...) # recursively adds containers and contents
# serializer.addObject(...) # adds object and anything it's carrying
# serializer.writeFile(filename)
class Serializer:
    def __init__(self):
        ## Maps object IDs to serializations of those objects.
        self.idToObjectSerialization = {}
        ## Maps objects to their Pyrel-generated IDs.
        self.objectToId = {}
        ## Maps object IDs to those objects; mostly useful for debugging.
        self.idToObject = {}
        ## ID of the GameMap being serialized.
        self.gameMapId = None
        ## Incrementing ID for tuples that have been converted into lists.
        self.tupleId = 0
        ## Maps tuple IDs (above) to the contents of those tuples.
        self.tupleIdToContents = {}


    ## Add the specified object to our serialization, as well as any containers
    # it contains.
    def addObject(self, obj):
        if obj.__class__.__name__ not in NAME_TO_DESERIALIZATION_FUNCS:
            # This object hasn't registered itself as valid for 
            # deserialization, so we won't serialize it either.
            raise RuntimeError("Tried to serialize object of type %s which was not registered as a serializable type with registerObjectClass." % obj.__class__.__name__)
        if obj.id in self.idToObject:
            # We've already processed this object.
            # Sanity check: make sure this actually is the same object.
            if obj is not self.idToObject[obj.id]:
                raise RuntimeError(u"Tried to serialize multiple objects with the same ID %s: %s vs. %s" % (obj.id, self.idToObject[obj.id], obj))
            return
        self.idToObject[obj.id] = obj
        try:
            # HACK: check for the GameMap, which we need to keep track of.
            if obj.__class__.__name__ == mapgen.gameMap.GameMap.__name__:
                if self.gameMapId is not None:
                    raise RuntimeError("Tried to serialize multiple GameMap instances.")
                self.gameMapId = obj.id
            objectData = obj.getSerializationDict()
            # Add the object's class name to its serialization so we can 
            # extract it later.
            self.idToObjectSerialization[obj.id] = {
                    'type': obj.__class__.__name__, 
                    'data': self.cleanDict(objectData, obj)}
            self.objectToId[obj] = obj.id
            # Check for object references in the provided dict.
            self.addObjectData(objectData)
        except Exception, e:
            # Add the object we failed on, to make debugging easier.
            raise RuntimeError("Failed to add object %s: %s\n%s" % (unicode(obj), e, traceback.format_exc()))


    ## Recursively examine the provided dictionary of object data for
    # references to other objects, which also need to be added to the 
    # serialization.
    def addObjectData(self, data):
        for key, value in data.iteritems():
            if self.getIsObjectReference(key):
                self.addObject(key)
            if self.getIsObjectReference(value):
                self.addObject(value)
            elif isinstance(value, list):
                # Check each element of the list
                for entry in value:
                    if self.getIsObjectReference(entry):
                        self.addObject(entry)
            elif isinstance(value, dict):
                # Recurse
                self.addObjectData(value)
            # Otherwise: don't care about the type.


    ## Write out our serialization to the given filename.
    def writeFile(self, filename):
        handle = open(filename, 'w')
        handle.write('{\n')
        
        # Do a special dump of the GameMap object, since it needs to be 
        # loaded before any other objects and thus needs to be easily-found
        # when deserializing.
        if self.gameMapId is None:
            raise RuntimeError("No GameMap provided for serialization.")
        try:
            serialization = self.idToObjectSerialization[self.gameMapId]
        except Exception, e:
            raise RuntimeError("Failed to sanitize serialization for GameMap: %s\n%s" % (e, traceback.format_exc()))
        output = json.dumps(serialization, sort_keys = True, indent = 2)
        handle.write('"gameMap": %s,\n\n' % output)

        # Write out all the tuples we had to generate while cleaning the 
        # object serializations.
        output = json.dumps(self.tupleIdToContents, 
                sort_keys = True, indent = 2)
        handle.write('"tuples": %s,\n\n' % output)

        # Now the objects themselves. 
        idToObjectDump = dict(self.idToObjectSerialization)
        del idToObjectDump[self.gameMapId]
        output = json.dumps(idToObjectDump, sort_keys = True, indent = 2)
        handle.write('"objects": %s' % output)

        handle.write('}\n')
        handle.close()


    ## Given a dict, ensure that it's ready for serialization. We do some
    # replacements (see cleanValue() below) and 
    # ensure that everything is of a valid type. We also recurse through
    # lists and dicts.
    # We pass along the parentage (i.e. recursion chain) to make debugging
    # easier if things go wrong.
    def cleanDict(self, inputDict, *parents):
        result = {}
        for key, value in inputDict.iteritems():
            newKey = self.cleanValue(key, key, *parents)
            # HACK: because JSON cannot have dict keys that are anything 
            # besides strings, we will be auto-converting strings of numbers
            # into numbers when we deserialize. Thus we cannot have an actual
            # string-of-numbers at this point, because it would also be 
            # converted at the other end. 
            if isinstance(newKey, types.StringTypes) and newKey.isdigit():
                raise ValueError("Tried to serialize a string of numbers [%s], which is invalid. Parentage: [%s]" % (newKey, unicode(parents)))
            newValue = self.cleanValue(value, key, *parents)
            result[newKey] = newValue
        return result


    ## Given a value, recursively "clean" it per the commentary for cleanDict.
    # We have different behaviors depending on the type of the value we're
    # cleaning. This function is basically a big if/elif/elif/... structure
    # testing the type of the value, sorted by the expected frequency of 
    # the different types, as a simple optimization.
    def cleanValue(self, value, *parents):
        if isinstance(value, (types.StringTypes, types.IntType, types.NoneType)):
            # These types can just be used straight up.
            return value
        elif self.getIsObjectReference(value):
            # Value is an object reference.
            return self.makeObjectReferenceString(value, *parents)
        elif isinstance(value, set):
            # Convert the set into a list with a special first field.
            return ['__pyrelSet'] + [self.cleanValue(v, value, *parents) for v in value]
        elif isinstance(value, tuple):
            # Convert the tuple into a string with a reference to the tuple's
            # contents, which are store elsewhere. We do this because tuples
            # are usable as dictionary keys in Python, but only strings can
            # be used as such in JSON. 
            usedId = self.tupleId
            result = '__pyrelTuple:%d' % usedId
            self.tupleId += 1
            # Note that the recursion here may create new "JSONized tuples",
            # hence why we have to temporarily store a copy of self.tupleId. 
            self.tupleIdToContents[usedId] = [self.cleanValue(v, value, *parents) for v in value]
            return result
        elif isinstance(value, dict):
            # Recurse
            return self.cleanDict(value, *parents)
        elif isinstance(value, list):
            # Check each value in turn.
            return [self.cleanValue(v, value, *parents) for v in value]
        elif isinstance(value, types.MethodType):
            # Value is a function.
            return self.makeFunctionString(value, *parents)
        else:
            # Check for any other types we can serialize; reject everything
            # else. 
            if isinstance(value, (types.BooleanType, types.FloatType, types.LongType)):
                return value
        # Unrecognized type.
        raise RuntimeError("Attempted to serialize unrecognized object %s of type %s. Parentage: %s" % (value, type(value), unicode(parents)))


    ## Given an input object that is a function, generate a string of the 
    # form
    # "__pyrelFunctionPointer__:object ID:function name".
    def makeFunctionString(self, func, *parents):
        # The im_self field on functions contains the object the function
        # is bound to. 
        obj = func.im_self
        # Ensure the object that the function is bound to will be serialized.
        if obj not in self.objectToId:
            if obj.__class__.__name__ in NAME_TO_DESERIALIZATION_FUNCS:
                # We can serialize this type of object.
                self.addObject(obj)
            else:
                raise RuntimeError("Tried to serialize a function reference \"%s\" for an object of unserializable type %s: %s. Parentage: %s" % (func.__name__, obj.__class__.__name__, unicode(obj), unicode(parents)))
        boundId = obj.id
        # The __name__ field is the function's name in string form.
        funcName = func.__name__
        return "__pyrelFunctionPointer__:%s:%s" % (boundId, funcName)


    ## Given an input object that is an object reference, generate a string
    # of the form
    # "__pyrelObjectReference__:object ID"
    def makeObjectReferenceString(self, obj, *parents):
        # Ensure the object that the function is bound to will be serialized.
        if obj not in self.objectToId:
            if obj.__class__.__name__ in NAME_TO_DESERIALIZATION_FUNCS:
                self.addObject(obj)
            else:
                raise RuntimeError("Tried to serialize a reference to an object of unserializable type %s: %s. Parentage: %s" % (obj.__class__.__name__, unicode(obj), unicode(parents)))
        return "__pyrelObjectReference__:%s" % obj.id


    ## Return True if the object is a reference to a custom class. 
    # HACK: this check is nastier than it could otherwise be, because 
    # objects that inherit from builtin types (e.g. set, dict) don't
    # count as InstanceTypes. 
    def getIsObjectReference(self, value):
        return (isinstance(value, types.InstanceType) or
                hasattr(value, '__class__') and value.__class__.__name__ in NAME_TO_DESERIALIZATION_FUNCS)



## This class handles loading savefiles. Usage:
# deserializer = Deserializer()
# deserializer.loadFile(filename)
# creatures = deserializer.getContainer(container.CREATURES) etc...
class Deserializer:
    def __init__(self):
        ## Maps object IDs to those objects.
        self.idToObject = {}
        ## Maps object IDs to dicts holding the data for those objects.
        self.idToObjectData = {}
        ## Maps tuple IDs to actual tuples.
        self.tupleIdToContents = {}
        ## The newly-created GameMap.
        self.newMap = None


    ## Load the specified file, which was generated by Serializer.writeFile(),
    # and recreate the objects specified by the file. 
    def loadFile(self, filename):
        import time
        startTime = time.time()
        with open(filename, 'r') as filehandle:
            saveData = json.load(filehandle)

        # Load the GameMap, which we need to be able to hand to the 
        # other object types.
        # \todo This is pretty hackish, the way we know which parameters to
        # pull out and pass to the GameMap constructor.
        gameMapData = saveData['gameMap']
        self.newMap = self.loadObject(gameMapData['data']['id'], 
                gameMapData,
                width = gameMapData['data']['width'], 
                height = gameMapData['data']['height'])
        print "Recreated gameMap at %.2f" % (time.time() - startTime)

        for objectId, objectData in saveData['objects'].iteritems():
            if objectData['type'] not in NAME_TO_DESERIALIZATION_FUNCS:
                raise KeyError('Attempted to deserialize unregistered object type %s' % objectData['type'])
            self.loadObject(objectId, objectData, gameMap = self.newMap)

        print "Loaded objects at %.2f" % (time.time() - startTime)

        # Load our tuples, needed to reconstruct objects.
        for tupleId, contents in saveData['tuples'].iteritems():
            contents = tuple([self.fixValue(v) for v in contents])
            self.tupleIdToContents[tupleId] = contents
        print "Loaded tuples at %.2f" % (time.time() - startTime)

        # Now that all objects have been created, fix any special references
        # in their data and fill in the details in the actual objects. 
        for objectId, obj in self.idToObject.iteritems():
            objectData = self.fixData(self.idToObjectData[objectId])
            fillFunc = NAME_TO_DESERIALIZATION_FUNCS[obj.__class__.__name__][1]
            fillFunc(obj, objectData, self.newMap)
        print "Loading took %.2fs" % (time.time() - startTime)


    ## Load a single object, given its serialization dict and ID.
    def loadObject(self, objectId, objectData, **kwargs):
        if not objectId:
            raise ValueError("Trying to load an object of type %s with invalid/blank object ID" % (objectData['type']))
        objectId = self.convertToNumeric(objectId)
        createFunc = NAME_TO_DESERIALIZATION_FUNCS[objectData['type']][0]
        try:
            newObject = createFunc(**kwargs)
        except Exception, e:
            raise RuntimeError("Failed to create object of type [%s]: %s\n%s" % (objectData['type'], e, traceback.format_exc()))
        util.id.setId(newObject, objectId)
        self.idToObject[objectId] = newObject
        self.idToObjectData[objectId] = objectData['data']
        return newObject


    ## Retrieve the newly-created GameMap
    def getGameMap(self):
        return self.newMap


    ## Retrieve the specified object by its ID.
    def getObject(self, id):
        if id not in self.idToObject:
            raise ValueError("Tried to access nonexistent object with id [%s]" % id)
        return self.idToObject[id]


    ## Given a dict generated by deserializing an object earlier, fix any 
    # references to other objects -- recognizable as strings containing the 
    # substring "__pyrel"
    def fixData(self, inputDict):
        result = {}
        for key, value in inputDict.iteritems():
            newKey = self.fixValue(key)
            newKey = self.convertToNumeric(newKey)
            newValue = self.fixValue(value)
            result[newKey] = newValue
        return result


    ## Given a value, recursively "fix" it per the commentary for fixData.
    def fixValue(self, value):
        if isinstance(value, types.StringTypes):
            if value.startswith('__pyrel'):
                # We need to replace this value with a more complicated 
                # relationship, e.g. a function pointer.
                return self.interpretMagicString(value)
            return value
        elif isinstance(value, dict):
            # Recurse
            return self.fixData(value)
        elif isinstance(value, list):
            # Check if we need to convert this to a set. We can
            # recognize this because the first element will be 
            # "__pyrelSet". Every remaining element must be fixed
            # individually.
            if len(value) > 0 and value[0] == '__pyrelSet':
                return set([self.fixValue(v) for v in value[1:]])
            return [self.fixValue(v) for v in value]
        # Default: return value as-is.
        return value


    ## Given an input string, generate a reference to another code object, 
    # which may be a function pointer, an object reference, or a tuple. 
    # These strings take the form of:
    # "__pythonSerializerSomethingSomething:arg1:arg2:...". 
    def interpretMagicString(self, magicString):
        if magicString.startswith('__pyrelFunctionPointer'):
            # Generate a function pointer. First arg is the object ID, second
            # is the name of the function. 
            junk, objectId, funcName = magicString.split(':')
            objectId = self.convertToNumeric(objectId)
            return getattr(self.idToObject[objectId], funcName)
        elif magicString.startswith('__pyrelObjectReference'):
            # Generate an object reference. First and only arg is the object ID.
            junk, objectId = magicString.split(':')
            objectId = self.convertToNumeric(objectId)
            result = self.idToObject.get(objectId, None)
            if result is None:
                # Couldn't find the object in either location.
                raise ValueError("Object reference to nonexistent object with ID [%s]" % objectId)
            return result
        elif magicString.startswith('__pyrelTuple'):
            junk, tupleId = magicString.split(':')
            if tupleId not in self.tupleIdToContents:
                raise ValueError("Tuple reference to nonexistent tuple with ID [%s]" % tupleId)
            return self.tupleIdToContents[tupleId]
        else:
            raise RuntimeError("Unrecognized special deserialization string [%s]" % magicString)


    # HACK: JSON keys can only be strings, but most of our object IDs (which
    # we use as keys in the serialization) are integers, as may be other 
    # dictionary keys we load. So any time we load a key, we try to convert
    # it to an integer. This does mean that actual strings-of-digits used as 
    # keys won't survive serialization...
    def convertToNumeric(self, value):
        if not isinstance(value, str) and not isinstance(value, unicode):
            # Value is not a string; nothing to be done here.
            return value
        if (value.isdigit() or (len(value) > 1 and value[0] == '-' and value[1:].isdigit())):
            return int(value)
        return value

